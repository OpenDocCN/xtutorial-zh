# 浮点

> 原文:[https://cs harp . net-tutorials . com/data-types/floating-points/](https://csharp.net-tutorials.com/data-types/floating-points/)

浮点数是有小数部分的数字(通常用小数点表示)。你可能想知道为什么没有单一的数据类型来处理数字(分数或者没有分数)，但那是因为计算机处理整数比处理包含分数的数字要快得多。因此区分它们是有意义的——如果你知道你将只处理整数，选择整数数据类型。否则，使用浮点数据类型之一，如本文所述。

使用浮点值和使用整数一样简单，尽管浮点值还有很多问题，我们将在后面讨论。现在，让我们看看当声明一个最常用的浮点数据类型时是什么样子的: *double* 。

```
double number;
```

就像整数一样，您当然可以在声明它的同时给它赋值:

```
double number = 42.0;
```

这同样适用于 float 和 decimal 类型，我们马上就要讨论这两种类型，但是在这里，符号略有不同:

<input type="hidden" name="IL_IN_ARTICLE">

```
double doubleVal = 42.0;
float floatVal = 42.0f;
decimal decimalVal = 42.0m;
```

注意数字后面的“f”和“m”——它告诉编译器我们在给一个浮点数和一个十进制值赋值。如果没有它，C#将把数字解释为 double，不能自动转换为 float 或 decimal。

## 浮点数、双精度数还是十进制数？

在编程中处理浮点值总是会引起很多问题和担忧。例如，C#至少有三种数据类型来处理非整数/非整数:

*   *float* (系统的别名。单身)
*   *double* (系统的别名。双倍)
*   *十进制*(系统的别名。十进制)

潜在的区别可能有点难以理解，除非你有很多关于计算机内部工作方式的知识，所以让我们在这里坚持更实际的东西。

一般来说，浮点、双精度和十进制数据类型之间的区别在于精度，因此也在于使用多少内存来保存它们。float 是最便宜的一种——它可以表示一个 7 位数的数。double 更精确，最多可达 16 位，而 decimal 最精确，最高可达 29 位。

你可能想知道为什么你需要那么精确，但答案是“数学的东西”。理解区别的经典例子是用 3 除 10。我们大多数人会在脑子里这么想，然后说结果是 3.33，但是很多人也知道这并不完全准确。真正的答案是 3.33，后面跟了一些额外的 3，用 C#做这个计算时，有多少是由数据类型决定的。看看这个例子:

```
float a = 10f / 3;
Console.WriteLine(a);
double b = 10d / 3;
Console.WriteLine(b);
decimal c = 10m / 3;
Console.WriteLine(c);
```

我做完全相同的计算，但是使用不同的数据类型。结果将如下所示:

```
a: 3.333333
b: 3.33333333333333
c: 3.3333333333333333333333333333
```

区别很明显，但是对于大多数任务，您真正需要的精度是多少呢？

### 如何选择

首先，你要考虑你需要存储多少位数。一个浮点数只能包含 7 个数字，所以如果你需要一个更大的数字，你可以用双精度或十进制来代替。

其次，float 和 double 都将值表示为实际值的近似值——换句话说，它可能无法精确到最后一位数。这也意味着，一旦你开始用这些变量做越来越多的计算，它们可能不再精确，这基本上意味着两个应该相等的值会突然变得不相等。

因此，对于精度是首要考虑的情况，您应该选择十进制类型。一个很好的例子是表示财务数字(钱)——你不想在你的簿记中增加 10 个金额，只是为了发现结果不是你所期望的。另一方面，如果性能更重要，你应该选择*浮动*(小数字)或*双*(大数字)。由于其额外的精度，十进制数比浮点数慢得多——一些测试表明它慢了 20 倍！

## 摘要

当处理浮点值时，当精度没有性能重要时，应该使用一个 *float* 或一个 *double* 数据类型。另一方面，如果您希望最大程度的精确，并且愿意接受较低的性能水平，那么您应该选择 decimal 数据类型——尤其是在处理财务数字时。

如果您想更详细地了解这些数据类型之间的潜在差异，您应该看看这篇非常详细的文章:[每个计算机科学家都应该知道的浮点运算](https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)

* * *