# 动作

> 原文：<https://asp.mvc-tutorial.com/controllers/actions/>

因为控制器只是一个普通的。NET 类，它可以有字段、属性和方法。控制器类的方法尤其有趣，因为它们是浏览器(因此也是用户)和应用之间的连接。因此，**控制器类的方法被称为动作**——一个方法通常对应于你的应用中的一个动作，然后这个动作向浏览器/用户返回一些东西。

由于浏览器是通过调用 URL 来工作的，所以需要将 URL 转换成相应的控制器和动作(方法)。例如，浏览器可能会请求一个类似于 */products/1/* 的 URL，然后您希望您的 *ProductsController* 用一个叫做 *Details* 的方法/动作来处理这个请求。这是通过路由的概念完成的，我们将在本教程的其他地方更多地讨论这个概念，但是现在，只需要知道**路由是连接 URL 和控制器**上的动作的东西。

当创建你的控制器时，记住**控制器类上的所有公共方法都被认为是一个动作**。这意味着，如果您已经为控制器定义了无所不包的路由规则(这是一件常见的事情)，那么理论上可以使用 URL 访问控制器类上的所有方法。因此，如果您的控制器上有您不希望最终用户能够调用的方法，请确保将其标签为**私有**。或者，如果您确实需要一个方法是公共的，但不能通过 URL 访问，那么您可以用*【非动作】*属性来标签该方法。

## 动作动词

为了更好地控制如何调用动作，可以用所谓的动作动词来修饰它们。这些事实上是有规律的。NET 属性，它将告诉。NET framework 如何访问操作。如果没有这些属性，可以使用所有可能的 HTTP 方法(最常见的是 GET 和 POST)来访问一个动作，但是您可以很容易地更改它:

```
[HttpGet]
public IActionResult Edit()
{
    return Content("Edit");
}
```

<input type="hidden" name="IL_IN_ARTICLE">

现在，编辑操作只能通过 GET 请求来访问。这有一个额外的好处，允许您拥有多个同名的方法，只要它们不接受相同的请求方法。例如，您可以有两个名为 Edit 的方法:第一个方法可用于 GET 请求并生成用于编辑项目的表单，而第二个方法仅可用于 POST 请求，并用于在表单回发到服务器时更新项目。它可能看起来像这样:

```
[HttpGet]
public IActionResult Edit()
{
    return View();
}

[HttpPost]
public IActionResult Edit(Product product)
{
    product.Save();
    return Content("Product updated!");
}
```

现在，每当对`Edit()`方法/动作发出请求时，响应请求的实际方法将基于它是 GET 请求还是 POST 请求。

在某些情况下，您可能想要指定多个动作动词，例如，指定一个动作可以被 POST 和 GET 请求访问，但不能被其他类型的请求访问。这同样简单:

```
[HttpGet]
[HttpPost]          
public IActionResult Edit()
{
    ...
```

## 摘要

我们现在已经了解了控制器最重要的一个方面:动作，有时被称为动作方法或仅仅是方法，因为这就是它们的基本内容。在下一篇文章中，我们将讨论这些动作的结果，称为动作结果。

* * *